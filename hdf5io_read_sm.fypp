! Submodule : hdf5io_read_sm
! Purpose   : read routines for hdf5io_t type
!
! Copyright 2021 Rich Townsend
!
! This file is part of the ForUM (Fortran Utility Modules)
! package. ForUM is free software: you can redistribute it and/or
! modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, version 3.
!
! ForUM is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'common.inc'
#:include 'hdf5io.inc'

submodule (hdf5io_m) hdf5io_read_sm

contains

   #:for obj_type, prefix in (('attr', 'h5a'), ('dset', 'h5d'))
      #:for rank in range(RANK_MAX+1)

         #:for type, suffix in zip(NUM_TYPES, NUM_SUFFIXES)

            subroutine read_${obj_type}$_${suffix}$_${rank}$_(self, item_name, data)

               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(out)  :: data${SPEC_LIST(rank)}$
               #:if rank > 0
                  contiguous :: data
               #:endif

               #:if rank > 0
                  integer(HSIZE_T) :: item_shape(${rank}$)
               #:endif
               integer(HID_T) :: mem_type_id
               integer        :: hdf_err
               integer(HID_T) :: item_id
               type(C_PTR)    :: data_ptr

               #:if rank > 0

                  ! Check shapes

                  call self%get_${obj_type}$_shape(item_name, item_shape)
                  @:ASSERT(ALL(item_shape == SHAPE(data)),shape mismatch)

               #:endif

               ! Read the item

               mem_type_id = mem_type_id_${suffix}$

               data_ptr = C_LOC(data)

               @:HDF5_CALL(${prefix}$open_f, self%group_id, item_name, item_id)
               @:HDF5_CALL(${prefix}$read_f, item_id, mem_type_id, data_ptr)
               @:HDF5_CALL(${prefix}$close_f, item_id)

               ! Finish

               return

            end subroutine read_${obj_type}$_${suffix}$_${rank}$_

         #:endfor

         #:for type, suffix in zip(CHAR_TYPES, CHAR_SUFFIXES)
            
            subroutine read_${obj_type}$_${suffix}$_${rank}$_(self, item_name, data)

               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(out)  :: data${SPEC_LIST(rank)}$
               #:if rank > 0
                  contiguous :: data
               #:endif

               #:if rank > 0
                  integer(HSIZE_T) :: item_shape(${rank}$)
               #:endif
               integer          :: hdf_err
               integer(HID_T)   :: mem_type_id
               type(C_PTR)      :: data_ptr
               integer(HID_T)   :: item_id

               #:if rank > 0

                  ! Check shapes

                  call self%get_${obj_type}$_shape(item_name, item_shape)
                  @:ASSERT(ALL(item_shape == SHAPE(data)),shape mismatch)

               #:endif
         
               ! Read the character item

               @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, mem_type_id)
               @:HDF5_CALL(h5tset_size_f, mem_type_id, LEN(data, SIZE_T))

               data_ptr = C_LOC(data)

               @:HDF5_CALL(${prefix}$open_f, self%group_id, item_name, item_id)
               @:HDF5_CALL(${prefix}$read_f, item_id, mem_type_id, data_ptr)
               @:HDF5_CALL(${prefix}$close_f, item_id)

               @:HDF5_CALL(h5tclose_f, mem_type_id)

               ! Finish

               return

            end subroutine read_${obj_type}$_${suffix}$_${rank}$_

         #:endfor

         #:for type, suffix in zip(LOGICAL_TYPES, LOGICAL_SUFFIXES)   
            
            subroutine read_${obj_type}$_${suffix}$_${rank}$_(self, item_name, data)

               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(out)  :: data${SPEC_LIST(rank)}$
               #:if rank > 0
                  contiguous :: data
               #:endif

               #:if rank > 0
                  integer(HSIZE_T) :: item_shape(${rank}$)
               #:endif
               integer, allocatable :: data_i${SPEC_LIST(rank)}$

               ! Read the logical item

               #:if rank > 0

                  item_shape = SHAPE(data)

                  allocate(data_i${INDEX_LIST(rank, 'item_shape')}$)

               #:else

                  allocate(data_i)

               #:endif

               call self%read_${obj_type}$(item_name, data_i)

               data = data_i /= 0

               ! Finish

               return

            end subroutine read_${obj_type}$_${suffix}$_${rank}$_

         #:endfor
            
      #:endfor
   #:endfor

end submodule hdf5io_read_sm
