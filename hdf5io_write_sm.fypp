! Submodule : hdf5io_write_sm
! Purpose   : write routines for hdf5io_t type
!
! Copyright 2021 Rich Townsend
!
! This file is part of the ForUM (Fortran Utility Modules)
! package. ForUM is free software: you can redistribute it and/or
! modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, version 3.
!
! ForUM is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'common.inc'
#:include 'hdf5io.inc'

submodule (hdf5io_m) hdf5io_write_sm

contains

   #:for obj_type, prefix in (('attr', 'h5a'), ('dset', 'h5d'))
      #:for rank in range(RANK_MAX+1)

         #:for type, suffix in zip(NUM_TYPES, NUM_SUFFIXES)

            subroutine write_${obj_type}$_${suffix}$_${rank}$_(self, item_name, data)
            
               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(in)   :: data${SPEC_LIST(rank)}$
               #:if rank > 0
               contiguous :: data
               #:endif

               integer          :: hdf_err
               logical          :: item_exists
               integer(HSIZE_T) :: item_shape(${rank}$)
               integer(HID_T)   :: dspace_id
               integer(HID_T)   :: plist_id
               integer(HID_T)   :: mem_type_id
               integer(HID_T)   :: file_type_id
               type(C_PTR)      :: data_ptr
               integer(HID_T)   :: item_id

               ! Write the item

               #:if rank > 0
                  @:HDF5_CALL(h5screate_simple_f, ${rank}$, INT(SHAPE(data), HSIZE_T), dspace_id)
               #:else
                  @:HDF5_CALL(h5screate_f, H5S_SCALAR_F, dspace_id)
               #:endif

               #:if obj_type == 'attr'
                  @:HDF5_CALL(h5pcreate_f, H5P_ATTRIBUTE_CREATE_F, plist_id)
               #:else
                  @:HDF5_CALL(h5pcreate_f, H5P_DATASET_CREATE_F, plist_id)
                  @:HDF5_CALL(h5pset_chunk_f, plist_id, ${rank}$, INT(SHAPE(data), HSIZE_T))
                  @:HDF5_CALL(h5pset_deflate_f, plist_id, self%comp_level)
               #:endif

               mem_type_id = mem_type_id_${suffix}$
               file_type_id = file_type_id_${suffix}$

               data_ptr = C_LOC(data)

               #:if obj_type == 'attr'
                  @:HDF5_CALL(${prefix}$create_f, self%group_id, item_name, file_type_id, dspace_id, item_id, acpl_id=plist_id)
               #:else
                  @:HDF5_CALL(${prefix}$create_f, self%group_id, item_name, file_type_id, dspace_id, item_id, dcpl_id=plist_id)
               #:endif

               @:HDF5_CALL(${prefix}$write_f, item_id, mem_type_id, data_ptr)
               @:HDF5_CALL(h5pclose_f, plist_id)
               @:HDF5_CALL(${prefix}$close_f, item_id)
               @:HDF5_CALL(h5sclose_f, dspace_id)

               ! Finish

               return

            end subroutine write_${obj_type}$_${suffix}$_${rank}$_

         #:endfor

         #:for type, suffix in zip(CHAR_TYPES, CHAR_SUFFIXES)

            subroutine write_${obj_type}$_${suffix}$_${rank}$_(self, item_name, data)

               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(in)   :: data${SPEC_LIST(rank)}$
               #:if rank > 0
                  contiguous :: data
               #:endif

               integer        :: hdf_err
               integer(HID_T) :: mem_type_id
               integer(HID_T) :: file_type_id
               integer(HID_T) :: dspace_id
               type(C_PTR)    :: data_ptr
               integer(HID_T) :: item_id

               ! Write the character item

               @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, mem_type_id)
               @:HDF5_CALL(h5tset_size_f, mem_type_id, LEN(data, SIZE_T))

               @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, file_type_id)
               @:HDF5_CALL(h5tset_size_f, file_type_id, LEN(data, SIZE_T))

               #:if rank > 0
                  @:HDF5_CALL(h5screate_simple_f, ${rank}$, INT(SHAPE(data), HSIZE_T), dspace_id)
               #:else
                  @:HDF5_CALL(h5screate_f, H5S_SCALAR_F, dspace_id)
               #:endif

               data_ptr = C_LOC(data)

               @:HDF5_CALL(${prefix}$create_f, self%group_id, item_name, file_type_id, dspace_id, item_id)
               @:HDF5_CALL(${prefix}$write_f, item_id, mem_type_id, data_ptr)
               @:HDF5_CALL(${prefix}$close_f, item_id)

               @:HDF5_CALL(h5sclose_f, dspace_id)

               @:HDF5_CALL(h5tclose_f, mem_type_id)
               @:HDF5_CALL(h5tclose_f, file_type_id)

               ! Finish

               return

            end subroutine write_${obj_type}$_${suffix}$_${rank}$_

         #:endfor

         #:for type, suffix in zip(LOGICAL_TYPES, LOGICAL_SUFFIXES)

            subroutine write_${obj_type}$_${suffix}$_${rank}$_ (self, item_name, data)

               class(hdf5io_t), intent(inout) :: self
               character(*), intent(in)       :: item_name
               ${type}$, target, intent(in)   :: data${SPEC_LIST(rank)}$
               #:if rank > 0
                  contiguous :: data
               #:endif

               ! Write the logical item

               call self%write_${obj_type}$(item_name, MERGE(1, 0, MASK=data))

               ! Finish

               return

            end subroutine write_${obj_type}$_${suffix}$_${rank}$_

         #:endfor

      #:endfor
   #:endfor
            
end submodule hdf5io_alloc_read_sm
